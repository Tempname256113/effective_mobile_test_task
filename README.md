**Задание 1**

Находится в директории /task1. Сами сервисы в директории apps

Сначала нужно установить зависимости приложения с помощью команды pnpm i, создать переменные окружения (пример какими должны быть переменные окружения в корне, файл называется .env.sample) и применить миграции с помощью команды pnpm knex migrate:latest

Далее перейти в сами микросервисы по путям /task1/apps/product-history-service и task1/apps/product-service соответственно и запустить оба приложения при помощи команды node index.mjs (у обоих микросервисов точка входа называется одинаково)

Реализовано 2 сервиса. Один сервис остатков товаров в магазине. У товара (вместе со связанными таблицами) есть следующие поля:
- PLU - артикул товара
- Название товара
- Количество товара на полке
- Количество товара в заказе
- Для какого магазина данных остаток
Данные денормализованы и приведены к 3 нормальной форме.

Реализованы следующие endpoints:
- Создание товара (POST /products, dtoSample = ```{
    "productName": "some new name"
}```)

- Создание остатка (POST /products/stock, dtoSample = ```{
    "productId": 11,
    "shopId": 1,
    "stockQuantity": 10,
    "orderQuantity": 5
}```)

- Увеличение остатка (PATCH /products/stock/increase, dtoSample = ```{
    "productId": 8,
    "shopId": 1,
    "stockQuantity": 10,
    "orderQuantity": 5
}```)

- Уменьшение остатка (PATCH /products/stock/decrease, dtoSample = ```{
    "productId": 8,
    "shopId": 1,
    "stockQuantity": 10,
    "orderQuantity": 5
}```)

- Получение остатков по фильтрам (GET /products/stock, dtoQuerySample = ```{
    "plu": "d949eeb7-f061-419a-997b-48fddebcb0fd",
    "shopId": 1,
    "stock_quantity_min": 5,
    "stock_quantity_max": 10,
    "order_quantity_min": 5,
    "order_quantity_max": 10
}```)

- Получение товаров по фильтрам (GET /products, dtoQuerySample = ```{
    "name": "some_name"
    "plu": "d949eeb7-f061-419a-997b-48fddebcb0fd",
}```)

Другой сервис истории действий с товарами.
В сервис “истории действий с товарами” отправляются все события, которые происходят с товарами или остатками. Общение сервисов происходит при помощи брокера сообщений rabbitmq. Сервис “истории действий с товарами или остатками” имеет endpoint, который отдает историю действий с фильтрами и постраничной навигацией (GET /products/history, dtoQuerySample = ```{
    "shop_id": 1,
    "plu": "b91a1c5d-0a4a-4cda-9e29-ed9cc14410ff",
    "date_after": "2024-09-11T14:52:49.195244Z", дата должна быть в формате ISO
    "date_before": "2024-09-11T14:48:19.932078Z", дата должна быть в формате ISO
    "action": "create_stock_to_product", всего есть несколько actions. это "create_product", "create_stock_to_product", "increase_product_stock" и  "decrease_product_stock"
    "page": 1,
    "limit": 10
}```)

В качестве фрейморвка в обоих сервисах используется fastify. Оба сервиса написаны на чистом JS, СУБД - postgresql, query builder - knex, общение сервисов - rabbitmq



**Задание 2**

Находится в директории task2

Базу данных здесь нужно использовать не ту же самую которая использовалась для первой задачи иначе будет ошибка из за того что миграций предыдущих здесь не хватает. Или удалить из бд таблицы knex_migrations и knex_migrations_lock и использовать ту же самую бд без возникновения ошибок

Сначала нужно установить зависимости приложения с помощью команды pnpm i, создать переменные окружения (пример какими должны быть переменные окружения в корне, файл называется .env.sample) и применить миграции с помощью команды pnpm knex migrate:latest

Далее запустить приложение находясь в директории /task2 с помощью команды pnpm run start

Реализован сервис, который работает с пользователями. В бд может быть более 1 миллиона пользователей (Создана миграция чтобы добавить в бд 1 миллион пользователей. У каждого добавленного пользователя есть 50% шанс иметь проблемы). Каждый пользователь имеет поля:
- Имя
- Фамилия
- Возраст
- Пол
- Проблемы: boolean // есть ли проблемы у пользователя
  
Реализован endpoint, который проставляет флаг проблемы у пользователей в false и считает, сколько пользователей имело true в этом флаге (PATCH /remove-users-problems, передавать сюда ничего не нужно)

В качестве фреймворка используется nestjs. Сервис написан на typescript, СУБД - postgres, query builder - knex
